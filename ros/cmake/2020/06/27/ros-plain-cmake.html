<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>(WIP) ROS Plain CMake | ü§ñ Tim √úbelh√∂rs blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="(WIP) ROS Plain CMake" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS." />
<meta property="og:description" content="Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS." />
<link rel="canonical" href="https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html" />
<meta property="og:url" content="https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html" />
<meta property="og:site_name" content="ü§ñ Tim √úbelh√∂rs blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-27T00:00:00-05:00" />
<script type="application/ld+json">
{"headline":"(WIP) ROS Plain CMake","dateModified":"2020-06-27T00:00:00-05:00","description":"Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS.","datePublished":"2020-06-27T00:00:00-05:00","@type":"BlogPosting","url":"https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://tuebel.github.io/blog/feed.xml" title="ü§ñ Tim √úbelh√∂rs blog" /><link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>(WIP) ROS Plain CMake | ü§ñ Tim √úbelh√∂rs blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="(WIP) ROS Plain CMake" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS." />
<meta property="og:description" content="Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS." />
<link rel="canonical" href="https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html" />
<meta property="og:url" content="https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html" />
<meta property="og:site_name" content="ü§ñ Tim √úbelh√∂rs blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-27T00:00:00-05:00" />
<script type="application/ld+json">
{"headline":"(WIP) ROS Plain CMake","dateModified":"2020-06-27T00:00:00-05:00","description":"Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS.","datePublished":"2020-06-27T00:00:00-05:00","@type":"BlogPosting","url":"https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://tuebel.github.io/blog/ros/cmake/2020/06/27/ros-plain-cmake.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://tuebel.github.io/blog/feed.xml" title="ü§ñ Tim √úbelh√∂rs blog" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">ü§ñ Tim √úbelh√∂rs blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About Me</a><a class="page-link" href="/blog/search/">Search</a><a class="page-link" href="/blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">(WIP) ROS Plain CMake</h1><p class="page-description">Tutorial on creating a plain CMake package without any ROS dependencies that can be used with ROS.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-06-27T00:00:00-05:00" itemprop="datePublished">
        Jun 27, 2020
      </time>
       ‚Ä¢ <span class="read-time" title="Estimated read time">
    
    
      10 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#ROS">ROS</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#CMake">CMake</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#motivation">Motivation</a></li>
<li class="toc-entry toc-h1"><a href="#example-repository">Example repository</a></li>
<li class="toc-entry toc-h1"><a href="#packagexml">package.xml</a></li>
<li class="toc-entry toc-h1"><a href="#cmakeliststxt">CMakeLists.txt</a>
<ul>
<li class="toc-entry toc-h2"><a href="#includes-and-settings">Includes and settings</a></li>
<li class="toc-entry toc-h2"><a href="#defining-targets">Defining targets</a></li>
<li class="toc-entry toc-h2"><a href="#installing-the-targets">Installing the targets</a></li>
<li class="toc-entry toc-h2"><a href="#export-targets">Export Targets</a></li>
<li class="toc-entry toc-h2"><a href="#package-configuration-generation">Package Configuration Generation</a></li>
<li class="toc-entry toc-h2"><a href="#the-configcmakein-file">The Config.cmake.in File</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#usage">Usage</a>
<ul>
<li class="toc-entry toc-h2"><a href="#catkin-workspace">Catkin Workspace</a></li>
<li class="toc-entry toc-h2"><a href="#cmake-system-installation">CMake System Installation</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a>
<ul>
<li class="toc-entry toc-h2"><a href="#references-and-useful-resources">References and Useful Resources</a></li>
</ul>
</li>
</ul><h1 id="motivation">
<a class="anchor" href="#motivation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation</h1>
<p>Even though it is considered best practice to separate the ROS code from the logic, they are commonly placed in the same ROS package.
To increase the reusability, the logic / algorithms should be placed in a different package which does not rely on the ROS bits.
This enables the community or colleagues to use the code in non-ROS projects.
However, this requires the programmer to manually add the packaging magic that catkin would do.
This blog post provides some insight on what is required to make a CMake project ‚Äòfind_packagable‚Äô.</p>

<h1 id="example-repository">
<a class="anchor" href="#example-repository" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example repository</h1>
<p>A minimal working example of a ROS workspace can be found <a href="https://github.com/Tuebel/ros_plain_cmake">here</a>.
This workspace contrains three packages:</p>
<ol>
  <li>
<a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/catkin_pkg">catkin_pkg</a>: test the plain_cmake package in a ROS workspace</li>
  <li>
<a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/consumer_cmake">consumer_cmake</a>: test the system installation of plain_cmake in another CMake project</li>
  <li>
<a href="https://github.com/Tuebel/ros_plain_cmake/tree/master/src/plain_cmake">plain_cmake</a>: minimal example of a plain CMake package for ROS
This blog post will fokus on the plain_cmake package.</li>
</ol>

<p>Importing the package into another CMake or catkin package is straight forward and tutorials can be found in the <a href="http://wiki.ros.org/catkin/Tutorials/CreatingPackage">ROS wiki</a>.</p>

<h1 id="packagexml">
<a class="anchor" href="#packagexml" aria-hidden="true"><span class="octicon octicon-link"></span></a>package.xml</h1>
<p>Even though a <code class="highlighter-rouge">package.xml</code> is not required for the CMake functionalities, it is still required in the context of ROS.
This file gets parsed by the build tool to determine the dependencies and the build order.
To mark our project as plain CMake we add the following tags to our <code class="highlighter-rouge">package.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;buildtool_depend&gt;</span>cmake<span class="nt">&lt;/buildtool_depend&gt;</span>

<span class="nt">&lt;exports&gt;</span>
  <span class="nt">&lt;build_type&gt;</span>cmake<span class="nt">&lt;/build_type&gt;</span>
<span class="nt">&lt;/exports&gt;</span>
</code></pre></div></div>

<p>Many dependencies can be installed via <a href="http://wiki.ros.org/rosdep">rosdep</a> so they should be added, too.
Make sure to visit <a href="http://rosindex.github.io/">rosindex</a> to find the correct name of the dependencies.
For example for linear algebra, matrix and vector operations the package could depend on <a href="http://eigen.tuxfamily.org/">Eigen</a>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;depend&gt;</span>eigen<span class="nt">&lt;/depend&gt;</span>
</code></pre></div></div>

<h1 id="cmakeliststxt">
<a class="anchor" href="#cmakeliststxt" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMakeLists.txt</h1>
<h2 id="includes-and-settings">
<a class="anchor" href="#includes-and-settings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Includes and settings</h2>
<p>First, we include some CMake helpers.
The former provides variables for default installation directories like <code class="highlighter-rouge">${CMAKE_INSTALL_LIBDIR}</code> while the former provides functions for the automatic generation of the CMake configuration files.
These files are mandatory for a CMake package to provide the <code class="highlighter-rouge">find_package</code> functionality.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include</span><span class="p">(</span>GNUInstallDirs<span class="p">)</span>
<span class="nb">include</span><span class="p">(</span>CMakePackageConfigHelpers<span class="p">)</span>
</code></pre></div></div>

<p>Afterwards, some variables are set to configure this package package.
We will use some modern features which require CMake version 3.1 or higher.
Then, we define a name and version for the package and set the C++ standard to version 11.
In the last line, we define the variable <code class="highlighter-rouge">ConfigPackageLocation</code> which contains the path where our CMake package configuration files will be installed.
Under Linux CMake will search in several locations for the Config.cmake file.
One of the locations is <code class="highlighter-rouge">lib/&lt;package name&gt;/</code> and we append <code class="highlighter-rouge">/cmake</code> to keep our installation directory clean.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.1<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>plain_cmake<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>PLAIN_CMAKE_VERSION 0.1<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 11<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>ConfigPackageLocation <span class="si">${</span><span class="nv">CMAKE_INSTALL_LIBDIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>/cmake<span class="p">)</span>
</code></pre></div></div>

<p>Finally, we need to include the dependencies of our package.
In this example, the Eigen3 library is required.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span> <span class="p">(</span>Eigen3 3.3 REQUIRED NO_MODULE<span class="p">)</span>
</code></pre></div></div>

<h2 id="defining-targets">
<a class="anchor" href="#defining-targets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining targets</h2>
<p>This step is very similar to defining targets in a catkin package.
In this example, we define a library named after project which consists of a single source file.
Instead of 
However, as the <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">CMake documentation</a> states: ‚ÄúInclude directories usage requirements commonly differ between the build-tree and the install-tree.‚Äù</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib<span class="p">)</span>
<span class="nf">target_sources</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib PRIVATE
  src/matrix_operations.cpp<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib PUBLIC
  $&lt;BUILD_INTERFACE:<span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/include&gt;
  $&lt;INSTALL_INTERFACE:include&gt;<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib PUBLIC Eigen3::Eigen<span class="p">)</span>
</code></pre></div></div>

<p>Moreover, we we define an application to showcase the installation and export of the targets later.
Since we defined the library earlier, this application only needs to be linked to this very library.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>example_app src/example_app.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>example_app <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib<span class="p">)</span>
</code></pre></div></div>

<h2 id="installing-the-targets">
<a class="anchor" href="#installing-the-targets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installing the targets</h2>
<p>The obvious reason for using <code class="highlighter-rouge">install(TARGETS)</code> is to copy the libraries, binaries and headers to a system directory, where it can be found by other projects.
The not so obvious reason is that we can use the <code class="highlighter-rouge">EXPORT</code> command to associate the installation targets with <code class="highlighter-rouge">${CMAKE_PROJECT_NAME}Targets</code>, which will be important in the next section.
The <code class="highlighter-rouge">ARCHIVE</code>, <code class="highlighter-rouge">LIBRARY</code> and <code class="highlighter-rouge">RUNTIME</code> <code class="highlighter-rouge">DESTINATION</code> commands define where the files will be installed.
Here, we use the GNUInstallDirs helper variables for the destination.
There also exists an option to set the includes destination via <code class="highlighter-rouge">INCLUDES DESTINATION</code>.
However, the includes destination has already been set via <code class="highlighter-rouge">target_include_directories</code> and thus can be omitted.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>TARGETS <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>_lib example_app
  EXPORT <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets
  ARCHIVE DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_LIBDIR</span><span class="si">}</span>
  LIBRARY DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_LIBDIR</span><span class="si">}</span>
  RUNTIME DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_BINDIR</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<p>The header files require a separate installation command to copy them to a system directory.
You can either use <code class="highlighter-rouge">install(FILES)</code> to install a list of files or <code class="highlighter-rouge">install(DIRECTORY)</code> to install a whole directory.
Since all header files of the example package are stored in the <em>include/plain_cmake</em> directory, we use the latter.
Again, we use a GNUInstallDirs variable for the include destination.
Please note the ‚Äú/‚Äù after the ‚Äúinclude‚Äù.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>DIRECTORY include/
  DESTINATION <span class="si">${</span><span class="nv">CMAKE_INSTALL_INCLUDEDIR</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="export-targets">
<a class="anchor" href="#export-targets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Export Targets</h2>
<p>In the last section we associated the install targets with <code class="highlighter-rouge">${CMAKE_PROJECT_NAME}Targets</code>.
Now, we can use this to generate the <em>plain_cmakeTargets.cmake</em> which will allow other projects to import our targets.
The <code class="highlighter-rouge">NAMESPACE</code> is be prepended to the target names, so the library can be linked via <code class="highlighter-rouge">plain_cmake::plain_cmake_lib</code>.
If you have not specified an installation, you could alternatively use <code class="highlighter-rouge">export(TARGETS)</code> to manually specify the targets.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export</span><span class="p">(</span>EXPORT <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets
  FILE <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets.cmake
  NAMESPACE <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>::<span class="p">)</span>
</code></pre></div></div>

<p>The export command makes the targets available in the build tree only.
To make the targets available for projects which are not part of the build tree, they also require an installation:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>EXPORT <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets
  FILE <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Targets.cmake
  NAMESPACE <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>::
  DESTINATION <span class="si">${</span><span class="nv">ConfigPackageLocation</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="package-configuration-generation">
<a class="anchor" href="#package-configuration-generation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Package Configuration Generation</h2>
<p>This section describes the steps required to enable the <code class="highlighter-rouge">find_package</code> mechanism.
For our plain_cmake project two files are required to turn it into a package:</p>
<ul>
  <li><em>plain_cmakeConfigVersion.cmake</em></li>
  <li><em>plain_cmakeConfig.cmake</em></li>
</ul>

<p>We can use the <code class="highlighter-rouge">CMakePackageConfigHelpers</code> for the generation of both files.
The <em>plain_cmakeConfigVersion.cmake</em> can easily be generated by specifying he version number of the package and a compatibility:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">write_basic_package_version_file</span><span class="p">(</span>
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>ConfigVersion.cmake
  VERSION <span class="si">${</span><span class="nv">PLAIN_CMAKE_VERSION</span><span class="si">}</span>
  COMPATIBILITY SameMajorVersion<span class="p">)</span>
</code></pre></div></div>

<p>Generating the <em>plain_cmakeConfig.cmake</em> involves a bit more work but we can use the <code class="highlighter-rouge">configure_package_config_file</code> helper which requires:</p>
<ul>
  <li>The <em>plain_cmakeConfig.cmake.in</em> makes the targets and dependencies available to the importing project.
This file will be explained in the next section.</li>
  <li>An output filename, which expands to <em>${CMAKE_CURRENT_BINARY_DIR}/plain_cmakeConfig.cmake</em>.</li>
  <li>The path where the <em>plain_cmakeConfig.cmake</em> will be installed, which is the same as the installation path of the <em>plain_cmakeTargets.cmake</em>.</li>
  <li>The ` PATHS_VARS <variable1> <variable2> ...` are variables of the installation locations.
Our example package only requires one variable `INCLUDE_INSTALL_DIR` for the location of the headers.</variable2></variable1>
</li>
</ul>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="p">(</span>INCLUDE_INSTALL_DIR <span class="si">${</span><span class="nv">CMAKE_INSTALL_INCLUDEDIR</span><span class="si">}</span><span class="p">)</span>
<span class="nf">configure_package_config_file</span><span class="p">(</span>
  <span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Config.cmake.in
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Config.cmake
  INSTALL_DESTINATION <span class="si">${</span><span class="nv">ConfigPackageLocation</span><span class="si">}</span>
  PATH_VARS INCLUDE_INSTALL_DIR<span class="p">)</span>
</code></pre></div></div>

<p>After generating both, the <em>ConfigVersion.cmake</em> and the <em>Config.cmake</em> files they can be installed to a system directory.
We use the same installation command that we used for the installation of the header files.
It is important, the installation <code class="highlighter-rouge">DESTINATION</code> matches the one specified in <code class="highlighter-rouge">configure_package_config_file</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>FILES 
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>Config.cmake
  <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="si">}</span>ConfigVersion.cmake
  DESTINATION <span class="si">${</span><span class="nv">ConfigPackageLocation</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="the-configcmakein-file">
<a class="anchor" href="#the-configcmakein-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>The <code class="highlighter-rouge">Config.cmake.in</code> File</h2>
<p>The first line will automatically be expanded by the config helpers to make the file relocatable.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@PACKAGE_INIT@
</code></pre></div></div>

<p>Next, we make the targets we defined earlier available to the consumer projects:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_CURRENT_LIST_DIR</span><span class="si">}</span>/plain_cmakeTargets.cmake<span class="p">)</span>
</code></pre></div></div>

<p>If we want to use our library in a catkin package we are required to set the variables <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code> and <code class="highlighter-rouge">plain_cmake_LIBRARIES</code>.
Otherwise <code class="highlighter-rouge">catkin_package()</code> would result in the following warning&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_package() DEPENDS on 'plain_cmake' but neither 'plain_cmake_INCLUDE_DIRS' nor 'plain_cmake_LIBRARIES' is defined.
</code></pre></div></div>

<p>As <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code> is a path and we would like our package to be relocatable, we use the <code class="highlighter-rouge">@PACKAGE_&lt;variable&gt;@</code> macro.
This macro expands the path variables from <code class="highlighter-rouge">PATH_VARS</code> we passed to <code class="highlighter-rouge">configure_package_config_file</code>.
Earlier, we set the <code class="highlighter-rouge">INCLUDE_INSTALL_DIR</code> variable to <code class="highlighter-rouge">${CMAKE_INSTALL_INCLUDEDIR}</code>.
When building the plain_cmake library in a catkin workspace, the macro <code class="highlighter-rouge">@PACKAGE_INCLUDE_INSTALL_DIR@</code> is the expanded <code class="highlighter-rouge">&lt;path to catkin_ws&gt;/devel/include</code> and can be accessed via <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code>.</p>

<p>The <code class="highlighter-rouge">set_and_check</code> helper checks whether the path we set actually exists.
Moreover, we populate the <code class="highlighter-rouge">plain_cmake_LIBRARIES</code> with our library target - notice the namespace.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">set_and_check</span><span class="p">(</span>plain_cmake_INCLUDE_DIRS <span class="s2">"@PACKAGE_INCLUDE_INSTALL_DIR@"</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>plain_cmake_LIBRARIES plain_cmake::plain_cmake_lib<span class="p">)</span>
</code></pre></div></div>

<p>Theoretically, we could use <code class="highlighter-rouge">find_package</code> and <code class="highlighter-rouge">target_link_libraries</code> to compile against our library now.
However this would result in an error that the target ‚ÄúEigen3::Eigen‚Äù was not be found.
Forwarding the dependencies is easy using the find dependency macro.
Simply insert the same package requirements as in <code class="highlighter-rouge">find_package</code> from the beginning of your <em>CMakeLists.txt</em>.
The difference to <code class="highlighter-rouge">find_package</code> is that this macro will return with an error message from the <em>Config.cmake</em> iif the package cannot be found.</p>

<p>Please note that there seems to be an issue with the expansion of the <code class="highlighter-rouge">@PACKAGE_&lt;...&gt;@</code> macros when using <code class="highlighter-rouge">find_dependency</code> before it.
When finding Eigen3 before setting the <code class="highlighter-rouge">plain_cmake_INCLUDE_DIRS</code> it would point to the Eigen3 include directory instead of the plain_cmake ones.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include</span><span class="p">(</span>CMakeFindDependencyMacro<span class="p">)</span>
<span class="nf">find_dependency</span><span class="p">(</span>Eigen3 3.3 REQUIRED NO_MODULE<span class="p">)</span>
</code></pre></div></div>

<p>Finally it is recommended to call the following to confirm that all required components have been found:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">check_required_components</span><span class="p">(</span>plain_cmake<span class="p">)</span>
</code></pre></div></div>

<h1 id="usage">
<a class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h1>
<p>Now, that we have completed our plain CMake package, it is time to use it in another project.
We implemented the package so that it can be used in the build tree of a catkin workspace or from a system installation.</p>

<h2 id="catkin-workspace">
<a class="anchor" href="#catkin-workspace" aria-hidden="true"><span class="octicon octicon-link"></span></a>Catkin Workspace</h2>
<p>Using the <code class="highlighter-rouge">plain_cmake</code> package is pretty straight forward, almost as using any other catkin package.
Catkin uses the package.xml to determine the build order.
Thus, we add the following line to the package.xml of the consumer package&gt;</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;depend&gt;</span>plain_cmake<span class="nt">&lt;/depend&gt;</span>
</code></pre></div></div>

<p>In the CMakeLists.txt of the catkin package we can use the <code class="highlighter-rouge">find_package</code> mechanism to include our plain CMake package.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span><span class="p">(</span>plain_cmake REQUIRED<span class="p">)</span> 
</code></pre></div></div>

<p>Catkin uses the <code class="highlighter-rouge">catkin_package</code> macro to generate the package configuration which we generated via <code class="highlighter-rouge">configure_package_config_file</code> and <code class="highlighter-rouge">write_basic_package_version_file</code>.
To forward our package further down the dependency tree, we have to add it as non-catkin dependency via <code class="highlighter-rouge">DEPENDS</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">catkin_package</span><span class="p">(</span>
 CATKIN_DEPENDS roscpp std_msgs
 DEPENDS plain_cmake<span class="p">)</span>
</code></pre></div></div>

<p>After <code class="highlighter-rouge">catkin_package</code> the targets of the catkin package can be defined.
For example, we can add a ROS node executable <code class="highlighter-rouge">test_node</code> that depends on the <code class="highlighter-rouge">plain_cmake_lib</code>.
If the package was found via <code class="highlighter-rouge">find_package</code>, the library can be linked via <code class="highlighter-rouge">target_link_library</code>.
Sine we exported the target in the namespace <code class="highlighter-rouge">plain_cmake</code> we have to link the node against <code class="highlighter-rouge">plain_cmake::plain_cmake_lib</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>test_node src/test_node.cpp<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span>test_node 
  PRIVATE <span class="si">${</span><span class="nv">catkin_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>test_node
  PRIVATE <span class="si">${</span><span class="nv">catkin_LIBRARIES</span><span class="si">}</span> plain_cmake::plain_cmake_lib<span class="p">)</span>
</code></pre></div></div>

<p>Finally, we can compile the whole catkin workspace.
As the plain CMake package makes it a mixed workspace, we cannot use <code class="highlighter-rouge">catkin_make</code>.
Instead, <code class="highlighter-rouge">catkin_make_isolated</code> or <code class="highlighter-rouge">catkin build</code> from the catkin_tools has to be used.
An example of the above can be found in <em>catkin_pkg</em> directory of the <a href="https://github.com/Tuebel/ros_plain_cmake">example repository</a>.</p>

<h2 id="cmake-system-installation">
<a class="anchor" href="#cmake-system-installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMake System Installation</h2>
<p>Since the <code class="highlighter-rouge">plain_cmake</code> package‚Äôs only catkin bit is the <em>package.xml</em>, it can be installed and used like any other system dependency.
Navigate to the <em>plain_cmake</em> directory and create a <em>build</em> directory to keep the workspace clean.
Inside this directory we can call the typical sequence of commands to build and install a CMake package.
For development, I prefer using <code class="highlighter-rouge">checkinstall</code> instead of <code class="highlighter-rouge">make install</code> because it enables an easy cleanup via your favorite package manager, for example <code class="highlighter-rouge">apt-get</code>.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd path/to/plain_cmake
mkdir build &amp;&amp; cd build
cmake ..
make
sudo checkinstall
</code></pre></div></div>

<p>After installing the package to the system, we can use it in another CMake project by finding it and linking against it just like in the catkin workspace example.
The only difference is, that we do not use the <code class="highlighter-rouge">catkin_package</code> macro.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span><span class="p">(</span>plain_cmake<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>app src/app.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>app plain_cmake::plain_cmake_lib<span class="p">)</span>
</code></pre></div></div>

<p>A full example can be found in the <em>consumer_cmake</em> directory of the <a href="https://github.com/Tuebel/ros_plain_cmake">example repository</a>.
Note that the cmake consumer package is not compiled by catkin as it does not include a <em>package.xml</em>.</p>

<h1 id="conclusion">
<a class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h1>
<p>We have implemented a plain CMake package that can be used in a catkin workspace and installed to the system.
Not depending on catkin makes it easier to share your work in a ROS-agnostic environment.
Moreover if you intend to transition to ROS2 in the near future, separating the algorithms and ROS bits might improve your experience.
If you have any questions or recommendations, feel free to comment or open a pull-request.</p>

<h2 id="references-and-useful-resources">
<a class="anchor" href="#references-and-useful-resources" aria-hidden="true"><span class="octicon octicon-link"></span></a>References and Useful Resources</h2>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="Tuebel/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/ros/cmake/2020/06/27/ros-plain-cmake.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Hacks, tricks and awesomeness for robots and you. GoROS!</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/Tuebel" title="Tuebel"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/TimUebelhoer" title="TimUebelhoer"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
